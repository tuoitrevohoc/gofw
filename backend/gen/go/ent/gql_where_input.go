// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/tuoitrevohoc/gofw/backend/gen/go/ent/credential"
	"github.com/tuoitrevohoc/gofw/backend/gen/go/ent/predicate"
	"github.com/tuoitrevohoc/gofw/backend/gen/go/ent/refreshtoken"
	"github.com/tuoitrevohoc/gofw/backend/gen/go/ent/restaurant"
	"github.com/tuoitrevohoc/gofw/backend/gen/go/ent/user"
)

// CredentialWhereInput represents a where input for filtering Credential queries.
type CredentialWhereInput struct {
	Predicates []predicate.Credential  `json:"-"`
	Not        *CredentialWhereInput   `json:"not,omitempty"`
	Or         []*CredentialWhereInput `json:"or,omitempty"`
	And        []*CredentialWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "public_key" field predicates.
	PublicKey             *string  `json:"publicKey,omitempty"`
	PublicKeyNEQ          *string  `json:"publicKeyNEQ,omitempty"`
	PublicKeyIn           []string `json:"publicKeyIn,omitempty"`
	PublicKeyNotIn        []string `json:"publicKeyNotIn,omitempty"`
	PublicKeyGT           *string  `json:"publicKeyGT,omitempty"`
	PublicKeyGTE          *string  `json:"publicKeyGTE,omitempty"`
	PublicKeyLT           *string  `json:"publicKeyLT,omitempty"`
	PublicKeyLTE          *string  `json:"publicKeyLTE,omitempty"`
	PublicKeyContains     *string  `json:"publicKeyContains,omitempty"`
	PublicKeyHasPrefix    *string  `json:"publicKeyHasPrefix,omitempty"`
	PublicKeyHasSuffix    *string  `json:"publicKeyHasSuffix,omitempty"`
	PublicKeyEqualFold    *string  `json:"publicKeyEqualFold,omitempty"`
	PublicKeyContainsFold *string  `json:"publicKeyContainsFold,omitempty"`

	// "data" field predicates.
	Data             *string  `json:"data,omitempty"`
	DataNEQ          *string  `json:"dataNEQ,omitempty"`
	DataIn           []string `json:"dataIn,omitempty"`
	DataNotIn        []string `json:"dataNotIn,omitempty"`
	DataGT           *string  `json:"dataGT,omitempty"`
	DataGTE          *string  `json:"dataGTE,omitempty"`
	DataLT           *string  `json:"dataLT,omitempty"`
	DataLTE          *string  `json:"dataLTE,omitempty"`
	DataContains     *string  `json:"dataContains,omitempty"`
	DataHasPrefix    *string  `json:"dataHasPrefix,omitempty"`
	DataHasSuffix    *string  `json:"dataHasSuffix,omitempty"`
	DataEqualFold    *string  `json:"dataEqualFold,omitempty"`
	DataContainsFold *string  `json:"dataContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CredentialWhereInput) AddPredicates(predicates ...predicate.Credential) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CredentialWhereInput filter on the CredentialQuery builder.
func (i *CredentialWhereInput) Filter(q *CredentialQuery) (*CredentialQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCredentialWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCredentialWhereInput is returned in case the CredentialWhereInput is empty.
var ErrEmptyCredentialWhereInput = errors.New("ent: empty predicate CredentialWhereInput")

// P returns a predicate for filtering credentials.
// An error is returned if the input is empty or invalid.
func (i *CredentialWhereInput) P() (predicate.Credential, error) {
	var predicates []predicate.Credential
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, credential.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Credential, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, credential.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Credential, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, credential.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, credential.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, credential.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, credential.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, credential.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, credential.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, credential.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, credential.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, credential.IDLTE(*i.IDLTE))
	}
	if i.PublicKey != nil {
		predicates = append(predicates, credential.PublicKeyEQ(*i.PublicKey))
	}
	if i.PublicKeyNEQ != nil {
		predicates = append(predicates, credential.PublicKeyNEQ(*i.PublicKeyNEQ))
	}
	if len(i.PublicKeyIn) > 0 {
		predicates = append(predicates, credential.PublicKeyIn(i.PublicKeyIn...))
	}
	if len(i.PublicKeyNotIn) > 0 {
		predicates = append(predicates, credential.PublicKeyNotIn(i.PublicKeyNotIn...))
	}
	if i.PublicKeyGT != nil {
		predicates = append(predicates, credential.PublicKeyGT(*i.PublicKeyGT))
	}
	if i.PublicKeyGTE != nil {
		predicates = append(predicates, credential.PublicKeyGTE(*i.PublicKeyGTE))
	}
	if i.PublicKeyLT != nil {
		predicates = append(predicates, credential.PublicKeyLT(*i.PublicKeyLT))
	}
	if i.PublicKeyLTE != nil {
		predicates = append(predicates, credential.PublicKeyLTE(*i.PublicKeyLTE))
	}
	if i.PublicKeyContains != nil {
		predicates = append(predicates, credential.PublicKeyContains(*i.PublicKeyContains))
	}
	if i.PublicKeyHasPrefix != nil {
		predicates = append(predicates, credential.PublicKeyHasPrefix(*i.PublicKeyHasPrefix))
	}
	if i.PublicKeyHasSuffix != nil {
		predicates = append(predicates, credential.PublicKeyHasSuffix(*i.PublicKeyHasSuffix))
	}
	if i.PublicKeyEqualFold != nil {
		predicates = append(predicates, credential.PublicKeyEqualFold(*i.PublicKeyEqualFold))
	}
	if i.PublicKeyContainsFold != nil {
		predicates = append(predicates, credential.PublicKeyContainsFold(*i.PublicKeyContainsFold))
	}
	if i.Data != nil {
		predicates = append(predicates, credential.DataEQ(*i.Data))
	}
	if i.DataNEQ != nil {
		predicates = append(predicates, credential.DataNEQ(*i.DataNEQ))
	}
	if len(i.DataIn) > 0 {
		predicates = append(predicates, credential.DataIn(i.DataIn...))
	}
	if len(i.DataNotIn) > 0 {
		predicates = append(predicates, credential.DataNotIn(i.DataNotIn...))
	}
	if i.DataGT != nil {
		predicates = append(predicates, credential.DataGT(*i.DataGT))
	}
	if i.DataGTE != nil {
		predicates = append(predicates, credential.DataGTE(*i.DataGTE))
	}
	if i.DataLT != nil {
		predicates = append(predicates, credential.DataLT(*i.DataLT))
	}
	if i.DataLTE != nil {
		predicates = append(predicates, credential.DataLTE(*i.DataLTE))
	}
	if i.DataContains != nil {
		predicates = append(predicates, credential.DataContains(*i.DataContains))
	}
	if i.DataHasPrefix != nil {
		predicates = append(predicates, credential.DataHasPrefix(*i.DataHasPrefix))
	}
	if i.DataHasSuffix != nil {
		predicates = append(predicates, credential.DataHasSuffix(*i.DataHasSuffix))
	}
	if i.DataEqualFold != nil {
		predicates = append(predicates, credential.DataEqualFold(*i.DataEqualFold))
	}
	if i.DataContainsFold != nil {
		predicates = append(predicates, credential.DataContainsFold(*i.DataContainsFold))
	}

	if i.HasUser != nil {
		p := credential.HasUser()
		if !*i.HasUser {
			p = credential.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, credential.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCredentialWhereInput
	case 1:
		return predicates[0], nil
	default:
		return credential.And(predicates...), nil
	}
}

// RefreshTokenWhereInput represents a where input for filtering RefreshToken queries.
type RefreshTokenWhereInput struct {
	Predicates []predicate.RefreshToken  `json:"-"`
	Not        *RefreshTokenWhereInput   `json:"not,omitempty"`
	Or         []*RefreshTokenWhereInput `json:"or,omitempty"`
	And        []*RefreshTokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "token" field predicates.
	Token             *string  `json:"token,omitempty"`
	TokenNEQ          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGT           *string  `json:"tokenGT,omitempty"`
	TokenGTE          *string  `json:"tokenGTE,omitempty"`
	TokenLT           *string  `json:"tokenLT,omitempty"`
	TokenLTE          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "refresh_at" field predicates.
	RefreshAt      *time.Time  `json:"refreshAt,omitempty"`
	RefreshAtNEQ   *time.Time  `json:"refreshAtNEQ,omitempty"`
	RefreshAtIn    []time.Time `json:"refreshAtIn,omitempty"`
	RefreshAtNotIn []time.Time `json:"refreshAtNotIn,omitempty"`
	RefreshAtGT    *time.Time  `json:"refreshAtGT,omitempty"`
	RefreshAtGTE   *time.Time  `json:"refreshAtGTE,omitempty"`
	RefreshAtLT    *time.Time  `json:"refreshAtLT,omitempty"`
	RefreshAtLTE   *time.Time  `json:"refreshAtLTE,omitempty"`

	// "expire_at" field predicates.
	ExpireAt      *time.Time  `json:"expireAt,omitempty"`
	ExpireAtNEQ   *time.Time  `json:"expireAtNEQ,omitempty"`
	ExpireAtIn    []time.Time `json:"expireAtIn,omitempty"`
	ExpireAtNotIn []time.Time `json:"expireAtNotIn,omitempty"`
	ExpireAtGT    *time.Time  `json:"expireAtGT,omitempty"`
	ExpireAtGTE   *time.Time  `json:"expireAtGTE,omitempty"`
	ExpireAtLT    *time.Time  `json:"expireAtLT,omitempty"`
	ExpireAtLTE   *time.Time  `json:"expireAtLTE,omitempty"`

	// "ip_address" field predicates.
	IPAddress             *string  `json:"ipAddress,omitempty"`
	IPAddressNEQ          *string  `json:"ipAddressNEQ,omitempty"`
	IPAddressIn           []string `json:"ipAddressIn,omitempty"`
	IPAddressNotIn        []string `json:"ipAddressNotIn,omitempty"`
	IPAddressGT           *string  `json:"ipAddressGT,omitempty"`
	IPAddressGTE          *string  `json:"ipAddressGTE,omitempty"`
	IPAddressLT           *string  `json:"ipAddressLT,omitempty"`
	IPAddressLTE          *string  `json:"ipAddressLTE,omitempty"`
	IPAddressContains     *string  `json:"ipAddressContains,omitempty"`
	IPAddressHasPrefix    *string  `json:"ipAddressHasPrefix,omitempty"`
	IPAddressHasSuffix    *string  `json:"ipAddressHasSuffix,omitempty"`
	IPAddressEqualFold    *string  `json:"ipAddressEqualFold,omitempty"`
	IPAddressContainsFold *string  `json:"ipAddressContainsFold,omitempty"`

	// "is_active" field predicates.
	IsActive    *bool `json:"isActive,omitempty"`
	IsActiveNEQ *bool `json:"isActiveNEQ,omitempty"`

	// "user_agent" field predicates.
	UserAgent             *string  `json:"userAgent,omitempty"`
	UserAgentNEQ          *string  `json:"userAgentNEQ,omitempty"`
	UserAgentIn           []string `json:"userAgentIn,omitempty"`
	UserAgentNotIn        []string `json:"userAgentNotIn,omitempty"`
	UserAgentGT           *string  `json:"userAgentGT,omitempty"`
	UserAgentGTE          *string  `json:"userAgentGTE,omitempty"`
	UserAgentLT           *string  `json:"userAgentLT,omitempty"`
	UserAgentLTE          *string  `json:"userAgentLTE,omitempty"`
	UserAgentContains     *string  `json:"userAgentContains,omitempty"`
	UserAgentHasPrefix    *string  `json:"userAgentHasPrefix,omitempty"`
	UserAgentHasSuffix    *string  `json:"userAgentHasSuffix,omitempty"`
	UserAgentEqualFold    *string  `json:"userAgentEqualFold,omitempty"`
	UserAgentContainsFold *string  `json:"userAgentContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RefreshTokenWhereInput) AddPredicates(predicates ...predicate.RefreshToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RefreshTokenWhereInput filter on the RefreshTokenQuery builder.
func (i *RefreshTokenWhereInput) Filter(q *RefreshTokenQuery) (*RefreshTokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRefreshTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRefreshTokenWhereInput is returned in case the RefreshTokenWhereInput is empty.
var ErrEmptyRefreshTokenWhereInput = errors.New("ent: empty predicate RefreshTokenWhereInput")

// P returns a predicate for filtering refreshtokens.
// An error is returned if the input is empty or invalid.
func (i *RefreshTokenWhereInput) P() (predicate.RefreshToken, error) {
	var predicates []predicate.RefreshToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, refreshtoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RefreshToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, refreshtoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RefreshToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, refreshtoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, refreshtoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, refreshtoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, refreshtoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, refreshtoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, refreshtoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, refreshtoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, refreshtoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, refreshtoken.IDLTE(*i.IDLTE))
	}
	if i.Token != nil {
		predicates = append(predicates, refreshtoken.TokenEQ(*i.Token))
	}
	if i.TokenNEQ != nil {
		predicates = append(predicates, refreshtoken.TokenNEQ(*i.TokenNEQ))
	}
	if len(i.TokenIn) > 0 {
		predicates = append(predicates, refreshtoken.TokenIn(i.TokenIn...))
	}
	if len(i.TokenNotIn) > 0 {
		predicates = append(predicates, refreshtoken.TokenNotIn(i.TokenNotIn...))
	}
	if i.TokenGT != nil {
		predicates = append(predicates, refreshtoken.TokenGT(*i.TokenGT))
	}
	if i.TokenGTE != nil {
		predicates = append(predicates, refreshtoken.TokenGTE(*i.TokenGTE))
	}
	if i.TokenLT != nil {
		predicates = append(predicates, refreshtoken.TokenLT(*i.TokenLT))
	}
	if i.TokenLTE != nil {
		predicates = append(predicates, refreshtoken.TokenLTE(*i.TokenLTE))
	}
	if i.TokenContains != nil {
		predicates = append(predicates, refreshtoken.TokenContains(*i.TokenContains))
	}
	if i.TokenHasPrefix != nil {
		predicates = append(predicates, refreshtoken.TokenHasPrefix(*i.TokenHasPrefix))
	}
	if i.TokenHasSuffix != nil {
		predicates = append(predicates, refreshtoken.TokenHasSuffix(*i.TokenHasSuffix))
	}
	if i.TokenEqualFold != nil {
		predicates = append(predicates, refreshtoken.TokenEqualFold(*i.TokenEqualFold))
	}
	if i.TokenContainsFold != nil {
		predicates = append(predicates, refreshtoken.TokenContainsFold(*i.TokenContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, refreshtoken.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, refreshtoken.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, refreshtoken.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, refreshtoken.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, refreshtoken.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, refreshtoken.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, refreshtoken.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, refreshtoken.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.RefreshAt != nil {
		predicates = append(predicates, refreshtoken.RefreshAtEQ(*i.RefreshAt))
	}
	if i.RefreshAtNEQ != nil {
		predicates = append(predicates, refreshtoken.RefreshAtNEQ(*i.RefreshAtNEQ))
	}
	if len(i.RefreshAtIn) > 0 {
		predicates = append(predicates, refreshtoken.RefreshAtIn(i.RefreshAtIn...))
	}
	if len(i.RefreshAtNotIn) > 0 {
		predicates = append(predicates, refreshtoken.RefreshAtNotIn(i.RefreshAtNotIn...))
	}
	if i.RefreshAtGT != nil {
		predicates = append(predicates, refreshtoken.RefreshAtGT(*i.RefreshAtGT))
	}
	if i.RefreshAtGTE != nil {
		predicates = append(predicates, refreshtoken.RefreshAtGTE(*i.RefreshAtGTE))
	}
	if i.RefreshAtLT != nil {
		predicates = append(predicates, refreshtoken.RefreshAtLT(*i.RefreshAtLT))
	}
	if i.RefreshAtLTE != nil {
		predicates = append(predicates, refreshtoken.RefreshAtLTE(*i.RefreshAtLTE))
	}
	if i.ExpireAt != nil {
		predicates = append(predicates, refreshtoken.ExpireAtEQ(*i.ExpireAt))
	}
	if i.ExpireAtNEQ != nil {
		predicates = append(predicates, refreshtoken.ExpireAtNEQ(*i.ExpireAtNEQ))
	}
	if len(i.ExpireAtIn) > 0 {
		predicates = append(predicates, refreshtoken.ExpireAtIn(i.ExpireAtIn...))
	}
	if len(i.ExpireAtNotIn) > 0 {
		predicates = append(predicates, refreshtoken.ExpireAtNotIn(i.ExpireAtNotIn...))
	}
	if i.ExpireAtGT != nil {
		predicates = append(predicates, refreshtoken.ExpireAtGT(*i.ExpireAtGT))
	}
	if i.ExpireAtGTE != nil {
		predicates = append(predicates, refreshtoken.ExpireAtGTE(*i.ExpireAtGTE))
	}
	if i.ExpireAtLT != nil {
		predicates = append(predicates, refreshtoken.ExpireAtLT(*i.ExpireAtLT))
	}
	if i.ExpireAtLTE != nil {
		predicates = append(predicates, refreshtoken.ExpireAtLTE(*i.ExpireAtLTE))
	}
	if i.IPAddress != nil {
		predicates = append(predicates, refreshtoken.IPAddressEQ(*i.IPAddress))
	}
	if i.IPAddressNEQ != nil {
		predicates = append(predicates, refreshtoken.IPAddressNEQ(*i.IPAddressNEQ))
	}
	if len(i.IPAddressIn) > 0 {
		predicates = append(predicates, refreshtoken.IPAddressIn(i.IPAddressIn...))
	}
	if len(i.IPAddressNotIn) > 0 {
		predicates = append(predicates, refreshtoken.IPAddressNotIn(i.IPAddressNotIn...))
	}
	if i.IPAddressGT != nil {
		predicates = append(predicates, refreshtoken.IPAddressGT(*i.IPAddressGT))
	}
	if i.IPAddressGTE != nil {
		predicates = append(predicates, refreshtoken.IPAddressGTE(*i.IPAddressGTE))
	}
	if i.IPAddressLT != nil {
		predicates = append(predicates, refreshtoken.IPAddressLT(*i.IPAddressLT))
	}
	if i.IPAddressLTE != nil {
		predicates = append(predicates, refreshtoken.IPAddressLTE(*i.IPAddressLTE))
	}
	if i.IPAddressContains != nil {
		predicates = append(predicates, refreshtoken.IPAddressContains(*i.IPAddressContains))
	}
	if i.IPAddressHasPrefix != nil {
		predicates = append(predicates, refreshtoken.IPAddressHasPrefix(*i.IPAddressHasPrefix))
	}
	if i.IPAddressHasSuffix != nil {
		predicates = append(predicates, refreshtoken.IPAddressHasSuffix(*i.IPAddressHasSuffix))
	}
	if i.IPAddressEqualFold != nil {
		predicates = append(predicates, refreshtoken.IPAddressEqualFold(*i.IPAddressEqualFold))
	}
	if i.IPAddressContainsFold != nil {
		predicates = append(predicates, refreshtoken.IPAddressContainsFold(*i.IPAddressContainsFold))
	}
	if i.IsActive != nil {
		predicates = append(predicates, refreshtoken.IsActiveEQ(*i.IsActive))
	}
	if i.IsActiveNEQ != nil {
		predicates = append(predicates, refreshtoken.IsActiveNEQ(*i.IsActiveNEQ))
	}
	if i.UserAgent != nil {
		predicates = append(predicates, refreshtoken.UserAgentEQ(*i.UserAgent))
	}
	if i.UserAgentNEQ != nil {
		predicates = append(predicates, refreshtoken.UserAgentNEQ(*i.UserAgentNEQ))
	}
	if len(i.UserAgentIn) > 0 {
		predicates = append(predicates, refreshtoken.UserAgentIn(i.UserAgentIn...))
	}
	if len(i.UserAgentNotIn) > 0 {
		predicates = append(predicates, refreshtoken.UserAgentNotIn(i.UserAgentNotIn...))
	}
	if i.UserAgentGT != nil {
		predicates = append(predicates, refreshtoken.UserAgentGT(*i.UserAgentGT))
	}
	if i.UserAgentGTE != nil {
		predicates = append(predicates, refreshtoken.UserAgentGTE(*i.UserAgentGTE))
	}
	if i.UserAgentLT != nil {
		predicates = append(predicates, refreshtoken.UserAgentLT(*i.UserAgentLT))
	}
	if i.UserAgentLTE != nil {
		predicates = append(predicates, refreshtoken.UserAgentLTE(*i.UserAgentLTE))
	}
	if i.UserAgentContains != nil {
		predicates = append(predicates, refreshtoken.UserAgentContains(*i.UserAgentContains))
	}
	if i.UserAgentHasPrefix != nil {
		predicates = append(predicates, refreshtoken.UserAgentHasPrefix(*i.UserAgentHasPrefix))
	}
	if i.UserAgentHasSuffix != nil {
		predicates = append(predicates, refreshtoken.UserAgentHasSuffix(*i.UserAgentHasSuffix))
	}
	if i.UserAgentEqualFold != nil {
		predicates = append(predicates, refreshtoken.UserAgentEqualFold(*i.UserAgentEqualFold))
	}
	if i.UserAgentContainsFold != nil {
		predicates = append(predicates, refreshtoken.UserAgentContainsFold(*i.UserAgentContainsFold))
	}

	if i.HasUser != nil {
		p := refreshtoken.HasUser()
		if !*i.HasUser {
			p = refreshtoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, refreshtoken.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRefreshTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return refreshtoken.And(predicates...), nil
	}
}

// RestaurantWhereInput represents a where input for filtering Restaurant queries.
type RestaurantWhereInput struct {
	Predicates []predicate.Restaurant  `json:"-"`
	Not        *RestaurantWhereInput   `json:"not,omitempty"`
	Or         []*RestaurantWhereInput `json:"or,omitempty"`
	And        []*RestaurantWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RestaurantWhereInput) AddPredicates(predicates ...predicate.Restaurant) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RestaurantWhereInput filter on the RestaurantQuery builder.
func (i *RestaurantWhereInput) Filter(q *RestaurantQuery) (*RestaurantQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRestaurantWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRestaurantWhereInput is returned in case the RestaurantWhereInput is empty.
var ErrEmptyRestaurantWhereInput = errors.New("ent: empty predicate RestaurantWhereInput")

// P returns a predicate for filtering restaurants.
// An error is returned if the input is empty or invalid.
func (i *RestaurantWhereInput) P() (predicate.Restaurant, error) {
	var predicates []predicate.Restaurant
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, restaurant.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Restaurant, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, restaurant.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Restaurant, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, restaurant.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, restaurant.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, restaurant.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, restaurant.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, restaurant.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, restaurant.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, restaurant.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, restaurant.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, restaurant.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, restaurant.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, restaurant.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, restaurant.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, restaurant.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, restaurant.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, restaurant.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, restaurant.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, restaurant.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, restaurant.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, restaurant.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, restaurant.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, restaurant.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, restaurant.NameContainsFold(*i.NameContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, restaurant.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, restaurant.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, restaurant.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, restaurant.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, restaurant.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, restaurant.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, restaurant.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, restaurant.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, restaurant.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, restaurant.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, restaurant.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, restaurant.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, restaurant.AddressContainsFold(*i.AddressContainsFold))
	}

	if i.HasOwner != nil {
		p := restaurant.HasOwner()
		if !*i.HasOwner {
			p = restaurant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, restaurant.HasOwnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRestaurantWhereInput
	case 1:
		return predicates[0], nil
	default:
		return restaurant.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordIsNil        bool     `json:"passwordIsNil,omitempty"`
	PasswordNotNil       bool     `json:"passwordNotNil,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "avatar" field predicates.
	Avatar             *string  `json:"avatar,omitempty"`
	AvatarNEQ          *string  `json:"avatarNEQ,omitempty"`
	AvatarIn           []string `json:"avatarIn,omitempty"`
	AvatarNotIn        []string `json:"avatarNotIn,omitempty"`
	AvatarGT           *string  `json:"avatarGT,omitempty"`
	AvatarGTE          *string  `json:"avatarGTE,omitempty"`
	AvatarLT           *string  `json:"avatarLT,omitempty"`
	AvatarLTE          *string  `json:"avatarLTE,omitempty"`
	AvatarContains     *string  `json:"avatarContains,omitempty"`
	AvatarHasPrefix    *string  `json:"avatarHasPrefix,omitempty"`
	AvatarHasSuffix    *string  `json:"avatarHasSuffix,omitempty"`
	AvatarIsNil        bool     `json:"avatarIsNil,omitempty"`
	AvatarNotNil       bool     `json:"avatarNotNil,omitempty"`
	AvatarEqualFold    *string  `json:"avatarEqualFold,omitempty"`
	AvatarContainsFold *string  `json:"avatarContainsFold,omitempty"`

	// "finished_registration" field predicates.
	FinishedRegistration    *bool `json:"finishedRegistration,omitempty"`
	FinishedRegistrationNEQ *bool `json:"finishedRegistrationNEQ,omitempty"`

	// "last_sign_in_at" field predicates.
	LastSignInAt       *time.Time  `json:"lastSignInAt,omitempty"`
	LastSignInAtNEQ    *time.Time  `json:"lastSignInAtNEQ,omitempty"`
	LastSignInAtIn     []time.Time `json:"lastSignInAtIn,omitempty"`
	LastSignInAtNotIn  []time.Time `json:"lastSignInAtNotIn,omitempty"`
	LastSignInAtGT     *time.Time  `json:"lastSignInAtGT,omitempty"`
	LastSignInAtGTE    *time.Time  `json:"lastSignInAtGTE,omitempty"`
	LastSignInAtLT     *time.Time  `json:"lastSignInAtLT,omitempty"`
	LastSignInAtLTE    *time.Time  `json:"lastSignInAtLTE,omitempty"`
	LastSignInAtIsNil  bool        `json:"lastSignInAtIsNil,omitempty"`
	LastSignInAtNotNil bool        `json:"lastSignInAtNotNil,omitempty"`

	// "credentials" edge predicates.
	HasCredentials     *bool                   `json:"hasCredentials,omitempty"`
	HasCredentialsWith []*CredentialWhereInput `json:"hasCredentialsWith,omitempty"`

	// "access_tokens" edge predicates.
	HasAccessTokens     *bool                     `json:"hasAccessTokens,omitempty"`
	HasAccessTokensWith []*RefreshTokenWhereInput `json:"hasAccessTokensWith,omitempty"`

	// "restaurants" edge predicates.
	HasRestaurants     *bool                   `json:"hasRestaurants,omitempty"`
	HasRestaurantsWith []*RestaurantWhereInput `json:"hasRestaurantsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, user.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, user.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordIsNil {
		predicates = append(predicates, user.PasswordIsNil())
	}
	if i.PasswordNotNil {
		predicates = append(predicates, user.PasswordNotNil())
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.Avatar != nil {
		predicates = append(predicates, user.AvatarEQ(*i.Avatar))
	}
	if i.AvatarNEQ != nil {
		predicates = append(predicates, user.AvatarNEQ(*i.AvatarNEQ))
	}
	if len(i.AvatarIn) > 0 {
		predicates = append(predicates, user.AvatarIn(i.AvatarIn...))
	}
	if len(i.AvatarNotIn) > 0 {
		predicates = append(predicates, user.AvatarNotIn(i.AvatarNotIn...))
	}
	if i.AvatarGT != nil {
		predicates = append(predicates, user.AvatarGT(*i.AvatarGT))
	}
	if i.AvatarGTE != nil {
		predicates = append(predicates, user.AvatarGTE(*i.AvatarGTE))
	}
	if i.AvatarLT != nil {
		predicates = append(predicates, user.AvatarLT(*i.AvatarLT))
	}
	if i.AvatarLTE != nil {
		predicates = append(predicates, user.AvatarLTE(*i.AvatarLTE))
	}
	if i.AvatarContains != nil {
		predicates = append(predicates, user.AvatarContains(*i.AvatarContains))
	}
	if i.AvatarHasPrefix != nil {
		predicates = append(predicates, user.AvatarHasPrefix(*i.AvatarHasPrefix))
	}
	if i.AvatarHasSuffix != nil {
		predicates = append(predicates, user.AvatarHasSuffix(*i.AvatarHasSuffix))
	}
	if i.AvatarIsNil {
		predicates = append(predicates, user.AvatarIsNil())
	}
	if i.AvatarNotNil {
		predicates = append(predicates, user.AvatarNotNil())
	}
	if i.AvatarEqualFold != nil {
		predicates = append(predicates, user.AvatarEqualFold(*i.AvatarEqualFold))
	}
	if i.AvatarContainsFold != nil {
		predicates = append(predicates, user.AvatarContainsFold(*i.AvatarContainsFold))
	}
	if i.FinishedRegistration != nil {
		predicates = append(predicates, user.FinishedRegistrationEQ(*i.FinishedRegistration))
	}
	if i.FinishedRegistrationNEQ != nil {
		predicates = append(predicates, user.FinishedRegistrationNEQ(*i.FinishedRegistrationNEQ))
	}
	if i.LastSignInAt != nil {
		predicates = append(predicates, user.LastSignInAtEQ(*i.LastSignInAt))
	}
	if i.LastSignInAtNEQ != nil {
		predicates = append(predicates, user.LastSignInAtNEQ(*i.LastSignInAtNEQ))
	}
	if len(i.LastSignInAtIn) > 0 {
		predicates = append(predicates, user.LastSignInAtIn(i.LastSignInAtIn...))
	}
	if len(i.LastSignInAtNotIn) > 0 {
		predicates = append(predicates, user.LastSignInAtNotIn(i.LastSignInAtNotIn...))
	}
	if i.LastSignInAtGT != nil {
		predicates = append(predicates, user.LastSignInAtGT(*i.LastSignInAtGT))
	}
	if i.LastSignInAtGTE != nil {
		predicates = append(predicates, user.LastSignInAtGTE(*i.LastSignInAtGTE))
	}
	if i.LastSignInAtLT != nil {
		predicates = append(predicates, user.LastSignInAtLT(*i.LastSignInAtLT))
	}
	if i.LastSignInAtLTE != nil {
		predicates = append(predicates, user.LastSignInAtLTE(*i.LastSignInAtLTE))
	}
	if i.LastSignInAtIsNil {
		predicates = append(predicates, user.LastSignInAtIsNil())
	}
	if i.LastSignInAtNotNil {
		predicates = append(predicates, user.LastSignInAtNotNil())
	}

	if i.HasCredentials != nil {
		p := user.HasCredentials()
		if !*i.HasCredentials {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCredentialsWith) > 0 {
		with := make([]predicate.Credential, 0, len(i.HasCredentialsWith))
		for _, w := range i.HasCredentialsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCredentialsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCredentialsWith(with...))
	}
	if i.HasAccessTokens != nil {
		p := user.HasAccessTokens()
		if !*i.HasAccessTokens {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccessTokensWith) > 0 {
		with := make([]predicate.RefreshToken, 0, len(i.HasAccessTokensWith))
		for _, w := range i.HasAccessTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccessTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAccessTokensWith(with...))
	}
	if i.HasRestaurants != nil {
		p := user.HasRestaurants()
		if !*i.HasRestaurants {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRestaurantsWith) > 0 {
		with := make([]predicate.Restaurant, 0, len(i.HasRestaurantsWith))
		for _, w := range i.HasRestaurantsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRestaurantsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasRestaurantsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
